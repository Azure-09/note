面试是一个挖掘候选人能力的过程，面试或易或难，甚至很多题目没有思路。遇到没有思路的情况，可以通过以下几点，来尽可能的争取加分而不是减分：

1、**坦诚**

一定要坦诚的告诉面试官，这个题目是自己不熟悉的领域。就算你不说，回答的时候，面试官也能感受到。因此，**切记不懂装懂**。

2、**拓展**

承认自己不理解后，要尝试根据自己以往经验，去讲述类似方案。但是注意，如果是概念性的东西，不要自己胡扯，就比如以下场景：

```text
问：“能解释一下 HTTP 协议中 302 这个状态码是什么吗？”
答：“我不记得了。”
（0 分）

问：“能解释一下 HTTP 协议中 302 这个状态码是什么吗？”
答：“哦，记不清了，我只记得 404 是找不到页面，304 是可以从缓存读取，5xx 是服务端错误”
（加分，了解一定 HTTP 状态）

问：“能解释一下 HTTP 协议中 302 这个状态码是什么吗？”
答：“啊，那个，应该是服务端错误吧？”
（倾向于面试不通过，不了解的时候瞎猜，这个特点对工作不利）
```

可以看到，不同的回答会有完全不同的结果。遇到自己不会的题目，通过介绍自己知道的相关知识，不仅不减分反而会加分。

然后，试图引导面试官去问自己擅长的领域，比如根面试官说“不好意思，这个方面我没关注太多，不是很熟悉。不过我对 xxx 领域更熟悉，你可以问我这方面的内容”。

3、**反问**

这一点并不是在向面试官挑衅，而是虚心向对方学习，看对方怎么回答。这样会显得你认真、好学。

总之，在面试中，除了要展示你的知识和能力外；最重要的是，让面试官看到你的态度。

## JavaScript

### 原型和原型链

面试官：**谈谈你对原型和原型链的理解**

候选人：首先在 JS 中，原型也是一个对象，它的作用是为其他对象提供“共享的属性和方法”。然后，在创建一个对象时，它的隐式原型会指向构造函数的显示原型 或 `null`。

由于，原型也是对象，因此原型也有原型，这样就形成了原型链。

面试官：**原型链有什么作用？**

候选人：当访问对象的属性（或方法）时，其实是在查询原型链。如果在该对象上找到了要访问的属性，则直接返回；否则，沿着原型链向上查找，以此类推；直到找到原型链末端的 `null`。

面试官：**那么如何实现继承呢？**

候选人：有三种方法，1、`Object.create()` 2、`Object.setPrototypeOf()` 3、ES6 中的 `extends` 关键字。

其中 `extends` 关键字的实现原理，就是采用了寄生组合式继承的方式。

寄生组合式继承就利用了 `Object.create()`，代码如下所示：

```js
function inheritPrototype(superType, subType) {
  // 继承父类型的原型
  var prototype = Object.create(superType.prototype);
  // 继承过来的原型上 constructor 会丢失，这里重新添加
  prototype.constructor = subType;
  // 将继承的原型赋予子类
  subType.prototype = prototype;
}

function SuperType(name) {
  this.name = name;
  this.hobby = ["sing", "tap", "rap"];
}

SuperType.prototype.sayName = function () {
  console.log(this.name);
};

function SubType(name, age) {
  SuperType.call(this, name);
  this.age = age;
}

// 子类继承父类的原型
inheritPrototype(SuperType, SubType);

SubType.prototype.sayAge = function () {
  console.log(this.age);
};

var sub = new SubType("foo", 20);
sub.sayName(); // => foo
sub.sayAge(); // => 20
```

## 综合

### 从 URL 输入到页面加载，发生了什么？

总的来说，**主要**有六点：

1. DNS 解析
2. 建立 TCP 连接
3. 发送 HTTP 请求
4. 服务端处理请求，并响应数据
5. 客户端接收响应数据，并渲染页面
6. 断开连接（TCP 四次挥手）

---

**输入提示**

在浏览器地址栏中输入内容后，浏览器会根据它的算法，匹配出几条 URL 或 信息。**敲下回车，如果最终输入的是 URL，就会开始 URL 解析。如果最终输入的不是 URL，就使用浏览器默认的搜索引擎去搜索**。

这里，我介绍一下如果最终输入的是 URL，会发生什么。

**URL 解析**

URL 中的字符都是 ASCII 字符，也就是说**非 ASCII 字符的都会进行转义处理**。这样可以保证兼容性和安全性。

接着，**提取其中的域名，然后开始 DNS 解析**。当然，如果是直接使用的 IP 就没有 DNS 解析这一步了。这里假设使用的是域名。

**1. DNS 解析**

DNS 解析就是把域名映射到 IP 的一个过程。具体步骤如下：

1. **检查浏览器中的 DNS 缓存**。如果有，直接使用；否则进行下一步。
2. **检查系统缓存**。也就是会**检测本地的 hosts 文件**，看是否存储了要访问的域名的 IP。如果有，直接使用（之前也有人利用这个原理进行科学上网，不过貌似并不能 100% 成功）。
3. **路由器缓存**。路由器也有 DNS 缓存。
4. **ISP 的 DNS 服务器缓存**。
5. **根域名服务器**。此处会进行迭代查询，查找顺序为：**根 DNS 服务器（`.`）=> 顶级域名服务器（例如：`.com`） => 二级域名服务器（例如：`google.com`） => ...（依次类推）**。如果找到了，就返回 IP；否则，返回给浏览器信息“找不到服务器地址”。

找到服务器的 IP 后，接下来就开始建立 TCP 连接。

**2. TCP 连接**

目前大多数应用是采用的 HTTP 协议，而 HTTP 协议是以 TCP/IP 协议为基础的。

**IP 的发出**

上述 DNS 解析时，获取了真实的 IP，然后再加上 URL 中的端口号，浏览器会调用系统的 `socket` 函数，请求一个 TCP 流套接字，再封装成 TCP 包，由系统发出。

**TCP 三次握手**

- 第一次握手

  浏览器发送一个 TCP 报文，其中标志位 `SYN = 1`，序号 `seq = x`。

- 第二次握手

  客户端回应一个 TCP 报文，其中标志位 `SYN = 1, ACK = 1`，序号 `seq = y`，确认号 `ack = x + 1`。

- 第三次握手

  浏览器回应一个 TCP 报文，其中标志位 `ACK = 1`，序号 `seq = x + 1`，确认号 `ack = y + 1`。

**3. 发送 HTTP 请求**

完成 TCP 握手后，可能会进行 TLS 握手，也就是走 HTTPS 协议。至于走 HTTP 协议还是走 HTTPS 协议，影响条件很多。比如：

- 用户只输入域名，浏览器默认走 HTTP 协议
- 用户通过 IP 访问，浏览器也会走 HTTP 协议
- 只有用户明确指定了 `https://` 前缀，浏览器才会走 HTTPS 协议

但是，我们平时直接输入域名，为什么浏览器走的是 HTTPS？这是因为，浏览器进行了一些判断和重定向。

比如，浏览器会根据域名检查 HSTS 列表，如果找到了 IP 则返回，并强制使用 HTTPS 协议发送请求。其次，如果在 HSTS 列表中没找到，会先发送一次 HTTP 请求，如果服务端启用了 HTTPS，则返回 302 响应；然后浏览器通过 HTTPS 协议重新发送请求。

这中间涉及了 HTTP 到 HTTPS 的重定向，因此这个过程可能受到攻击。这就是为什么使用了 HTTPS 还遭到攻击的原因。

**TLS 握手**

- 第一次握手

  - 客户端发起 TLS 连接请求，其中包含**支持的 TLS 版本、一个随机数、加密算法列表、压缩算法列表**
  - 服务端回应请求，回应的内容包括**要使用的 TLS 版本、一个随机数、要使用的加密算法、要使用的压缩算法**

- 第二次握手

  - 服务端将自己的证书发给客户端，然后发送 ServerHelloDone 消息
  - 客户端验证服务端发来的证书，如果不合法，则断开连接

- 第三次握手

  - 客户端发给服务端**一个随机数（pre-master-secret）**，并使用服务端证书中的公钥加密这个随机数

然后两端都有了三个随机数，它们分别使用协商的加密算法和三个随机数，生成“会话密钥”（master-secret）。

- 第四次挥手

  - 客户端发送编码改变通知（告诉服务端，接下来的数据使用会话密钥加密）
  - 客户端发送握手结束通知（其中包含之前所有握手信息的 Hash 和 MAC，供服务端校验）
  - 服务端同样会做上述操作

**HTTP 请求报文**

TLS 握手结束后，接下来的流程就和发送 HTTP 请求一样，只不过数据是加密了的。

HTTP 请求报文包括：**请求行、请求头、请求体**。

请求行包括：**请求方法、URI、协议版本**。

请求头用于传输一些附加信息，例如：`Content-Type`、`Cookie` 等。

请求体用于承载数据。

**4. 服务端处理请求，并响应数据**

**HTTP 响应报文**

HTTP 响应报文包括：**响应行、响应头、响应体**。

响应行包括：**协议版本、状态码、状态码描述**。

响应头也是用于传输一些附加信息，例如：`Set-Cookie` 用于在客户端种下 Cookie。

响应体也是用于承载数据。

**5. 客户端接收响应数据，并渲染页面**

客户端拿到响应的数据后，进行如下处理：

- HTML 解析为 DOM 树

  - 采用深度优先遍历，即构建完当前节点的所有子节点后，才会去构建下一个节点。

  - 如果构建 DOM 树的时候，遇到 `<script>` 标签，则停止构建，直到脚本执行完毕。

- CSS 解析为 CSS 规则树

  - 构建 CSS 规则树时，会停止 JS 的执行。

- 然后 CSS 规则树和 DOM 树结合，生成渲染树

  - 精简 CSS 选择器，可以加快渲染树的合成（例如使用 BEM 规则）

- 根据渲染树，计算每个节点的几何信息（位置、大小等）

  - 整个过程也可以叫做布局。布局完成后，如果元素的几何信息发生了改变，就会进行重新布局，也就是**回流**（重排）

- 然后根据计算的几何信息，绘制页面

  - 根据布局阶段，计算好的每个点的像素值，绘制到屏幕上
  - 如果这个阶段元素的装饰信息（比如：背景颜色、透明度）发生改变，就会引起**重绘**
  - 同样此时如果元素的几何信息发生改变，则会重新布局

**6. 断开 TCP 连接**

也就是 TCP 四次挥手。由于客户端或服务端都可以主动断开 TCP 连接，因此这里就以客户端主动断开 TCP 连接为例。具体过程如下：

- 第一次挥手

  浏览器发送 TCP 结束报文，其中标志位 `FIN = 1`，序号 `seq = x`。

- 第二次挥手

  服务端发送一个确认报文，其中标志位 `ACK = 1`，序号 `seq = y`，确认号 `ack = x + 1`。

经过了前两次挥手后，服务端还可以给客户端发送数据，但反过来不行。也就是此时处于半关闭的状态。

- 第三次挥手

  如果第二次挥手后，服务端发送完了数据，或者没数据要发送，则会发起挥手请求。

  服务端发送 TCP 结束报文，其中标志位 `FIN = 1`，序号 `seq = u`。

- 第四次挥手

  客户端发送确认报文，其中标志位 `ACK = 1`，序号 `seq = v`，确认号 `ack = u + 1`。

当服务端接收到，客户端发来的确认报文后，就会立即关闭 TCP 连接。而客户端需要等待两个最大传输时延后（2 MSL），才可以关闭 TCP 连接。

### 常见的 HTTP 状态码

- 2xx

  - 200 成功
  - 204 成功，但没有数据返回
  - 206 成功，但返回部分数据（数据范围由 `Content-Range` 指定）

- 3xx

  - 301 永久重定向（以 GET 方法重新请求）
  - 302, 303 临时重定向（以 GET 方法重新请求）
  - 307 临时重定向（以 POST 方法重新请求）
  - 304 资源未更新，应使用缓存

- 4xx

  - 400 请求报文中存在语法错误
  - 401 没有认证（身份）或认证失败
  - 403 没有权限
  - 404 未找到资源

- 5xx

  - 500 服务器处理请求时报错
  - 503 服务器无法处理请求（超负载或停机维护）

### event.target 和 event.currentTarget 区别

- event.target 触发事件的元素
- event.currentTarget 绑定事件的元素

举例如下：

```html
<div onclick="clickMe">
  <button>Click</button>
</div>

<script>
// 假设点击的是 button 元素
function clickMe(e) {
  console.log(e.target); // => button
  console.log(e.currentTarget); // => div
}
</script>
```

### 执行上下文

执行上下文就是**当前正在执行的“代码环境”**，分为“编译”和“执行”两个阶段。

**编译**：在此阶段，将**变量**或**函数的声明**提升到作用域顶部，并为变量提供默认值 `undefined`。
**执行**：在此阶段，会赋值之前提升的变量，并执行函数。

### GET 和 POST 区别

作用、参数、安全性、可缓存性

作用：

  - GET 一般用于获取资源
  - POST 一般用于提交数据

参数；

  - GET 将参数放入 URL 的查询参数中传递
  - POST 将参数放入 HTTP body 中传递

安全性：

  - POST 相比于 GET 较为安全
  - 但两者都是明文传输，因此确保安全要使用 HTTPS 协议

可缓存性：

  - GET 请求的资源可以被缓存
  - POST 请求的资源不能被缓存
