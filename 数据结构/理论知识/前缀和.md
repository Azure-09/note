## （数组）前缀和

有数组 A、B，每个 `B[i]` 都保存了 A 中 `[0...i]` 的和，此时 B 就是一个前缀和数组。

例如，我们求数组 `[1, 2, 3, 4]` 的前缀和：

```js
const A = [1, 2, 3, 4];
const B = [A[0]];

// 注意下标从 1 开始
for (let i = 1; i < A.length; i++) {
  B[i] = B[i - 1] + A[i];
}

console.log(B); // => [1, 3, 6, 10]
```

### 实际应用

如果我们想求 `arr[i...j]` 的和，虽然可以直接遍历求得。但是如果需要大量计算，遍历就显得很慢。

如果利用前缀和数组，就可以 `O(1)` 的时间求得 `arr[i...j]` 的和，直接一步操作 `pre[i] - pre[j]` 即可。

前缀和主要用在处理**数组区间的问题**上。例如：统计班上同学的考试成绩，在不同分段的百分比：

```js
const scores = [100, 99, 66, 33, 66];
// 试卷满分 100
const counts = new Array(100).fill(0);

// 统计每个分数有多少同学
for (const s of scores) {
  counts[s] += 1;
}

// 计算前缀和
for (let i = 1; i < counts.length; i++) {
  counts[i] += counts[i - 1];
}
```

如果想要知道 `[30, 70]` 分数段之间有多少位同学，就可以直接 `counts[70] - counts[30]` 来快速计算出该分段的人数，然后计算百分比也就很容易了。

### 解决算法问题

[560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

```
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1：

输入：nums = [1,1,1], k = 2
输出：2, [1,1] 与 [1,1] 为两种不同的情况。

说明：
- 数组的长度为 [1, 20,000]。
- 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。
```

通过分析可以看出，这是一个数组区间问题，也就是找出所有“元素相加等于 k 的区间”。

首先，计算出前缀和：

```js
var subarraySum = function (nums, k) {
  const len = nums.length;
  const pres = [nums[0]];

  for (let i = 1; i < len; i++) {
    pres[i] = pres[i - 1] + nums[i];
  }
};
```

然后，遍历前缀和数组：

```js
var subarraySum = function (nums, k) {
  const len = nums.length;
  const pres = [nums[0]];

  for (let i = 1; i < len; i++) {
    pres[i] = pres[i - 1] + nums[i];
  }

  let count = 0;
  // 穷举所有子数组
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < i; j++) {
      if (pres[i] - pres[j] === k) {
        count++;
      }
    }
  }

  return count;
};
```

直接暴力遍历很好理解，但是根本没法通过 LeetCode 测试用例。上面的代码中，有一个值得优化的地方：

```js
if (pres[i] - pres[j] === k) {
  count++;
}
```

这是为了找出所有和等于 k 的子数组，我们变一下形 `pres[j] === pres[i] - k`，两者依然等价。但后者的语义发生了改变：**只要前缀和数组 `pres[i]` 中，存在子前缀和数组 `pres[j]`，使得满足上式即可**。

也就是说，只要 `pres[i] - k` 是前缀和数组中的项，`pres[i] - k` 的出现次数，就相当于 `pres[j]` 的出现次数，就相当于 `pres[i] - k === pres[j]` 执行的次数，就相当于满足题目要求的数组区间的个数。

全部代码如下（已通过 LeetCode 提交）：

```js
var subarraySum = function (nums, k) {
  const len = nums.length;
  const pres = [nums[0]];
  const map = new Map();
  let count = 0;

  // 计算前缀和
  for (let i = 1; i < len; i++) {
    pres[i] = pres[i - 1] + nums[i];
  }

  // 前缀和为 0，默认记录一次
  // 可以处理 subarraySum([3], 3) 等类似情况
  map.set(0, 1);

  for (let i = 0; i < len; i++) {
    // 判断 pres[i] - k 是否是子前缀和
    if (map.has(pres[i] - k)) {
      // 计算所有 pres[i] - k 的出现次数
      count += map.get(pres[i] - k);
    }

    // 把所有子前缀和存 Hash 表
    if (map.has(pres[i])) {
      map.set(pres[i], map.get(pres[i]) + 1);
    } else {
      map.set(pres[i], 1);
    }
  }

  return count;
};
```

为了方便理解，上述代码先计算好前缀和数组，然后利用其求解。实际解题中，不用那么死板，可以边判断，边求前缀和：

```js
var subarraySum = function (nums, k) {
  const map = new Map();
  let pre = 0;
  let count = 0;

  map.set(0, 1);

  for (const num of nums) {
    pre += num;

    if (map.has(pre - k)) {
      count += map.get(pre - k);
    }

    if (map.has(pre)) {
      map.set(pre, map.get(pre) + 1);
    } else {
      map.set(pre, 1);
    }
  }

  return count;
};
```

### 相关题目

- [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)
- [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)
- [1248. 统计「优美子数组」](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)
