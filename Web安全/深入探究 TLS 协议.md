## HTTP 为什么不安全

HTTP 是明文传输协议，通信过程和数据传输都没有进行加密，也没有验证通信双方的身份。因此通信过程很容易遭到劫持、窃听、篡改等。

使用 HTTP 协议传输信息时，就好比邮寄信件，邮件会经过很多快递员，但是每个快递员都可以拆开邮件并读取内容（因为 HTTP 是明文传输的），所以邮件的内容可以被轻易窃取。除此之外，快递员还可以伪造、篡改邮件，使得用户最终收到的邮件是假的。

## HTTPS 如何保证安全

HTTPS = HTTP + SSL/TLS，如今 SSL 已废弃，这里我们只讨论 HTTP + TLS。

为了解决 HTTP 协议的问题，HTTPS 引入了**数据加密**和**身份验证机制**。在开始传输数据之前，通过安全可靠的 TLS 协议进行加密，从而保证后续加密传输数据的安全性。

## TLS 协议

**传输层安全性协议**（Transport Layer Security，**TLS**）及其前身**安全套接层**（Secure Sockets Layer，**SSL**）是一种安全协议，目的是为了保证**网络通信安全**和**数据完整性**。

受 TLS 协议保护的通信过程，具有以下一种或几种属性：

- 连接是安全的

  因为使用对称加密算法来加密传输的数据。对称加密的密钥是基于 TLS 握手阶段协商的[加密算法](https://en.wikipedia.org/wiki/Transport_Layer_Security#Key_exchange_or_key_agreement)和[共享密钥](https://en.wikipedia.org/wiki/Shared_secret)，为每一个连接唯一生成的。

  其中，**共享密钥**的协商是安全可靠的。如果有攻击者修改了通信，那么该修改一定会被检测出来并被阻止。并且即使攻击者处于整个连接的中间（窃听 TLS 握手），也无法利用窃听到的密钥。

- 连接是可靠的

  发送的每条消息都会通过[消息验证码](https://en.wikipedia.org/wiki/Message_authentication_code)（Message authentication code, MAC），来进行消息完整性检查。

- 可以使用公钥对通信双方进行身份验证

  该项一般只需要验证一方的身份（通常是服务端）。对于一些非常保密的应用，还是需要验证双方的身份。例如，金融机构往往只允许认证后的用户连入自己的网络。

TLS 协议包括两层：[TLS 记录](https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_record)和 [TLS 握手协议](https://en.wikipedia.org/wiki/Transport_Layer_Security#TLS_handshake)。本文主要讲述 TLS 握手协议。

由于诸多原因（主要是安全方面），SSL 协议三个版本（`SSL 1.0`，`SSL 2.0`，`SSL 3.0`）都已弃用。并且 `TLS 1.0`，`TLS 1.1` 版本也将在 2020 年弃用，因此目前主流的通信加密协议版本是 `TLS 1.2` 和 `TLS 1.3`。

## TLS 握手

一张图解 TLS 握手（下面会详细介绍）：

> 带证书的双向身份验证的 TLS 握手。

![](./img/tls-four-handshake.png)

> 图片原始来源：[Wikipedia - File:SSL handshake with two way authentication with certificates.svg](https://zh.wikipedia.org/wiki/File:SSL_handshake_with_two_way_authentication_with_certificates.svg)，由我翻译并绘制为中文。

详细过程如下：

- 一次握手

  - 客户端发送 ClientHello 消息，其中包含**支持的最高 TLS 协议版本**、**随机数**（稍后用于生成 “会话密钥”）、**加密算法列表**（如 RSA 公钥加密）和**压缩算法列表**

    1. 如果客户端正在尝试恢复握手，则它可以发送会话 ID。

       > 后面会讲到 TLS 握手中断和恢复。

    2. 如果客户端可以使用[应用协议协商](https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation)，则它可能包括受支持的应用程序协议列表，例如 [HTTP 2.0](https://en.wikipedia.org/wiki/HTTP/2)。

  - 服务端回应 ServerHello 消息，其中包含**要使用的 TLS 协议版本**、**随机数**（稍后用于生成 “会话密钥”）、**要使用的加密算法**和**要使用的压缩算法**

    1. 为了确认恢复握手，则服务端可以发送会话 ID。

    2. 要使用的协议版本应该是客户端和服务端都支持的最高版本。例如，客户端支持 TLS 1.1，服务端支持 TLS 1.2，则应该选择 TLS 1.1 版本。

- 二次握手

  - 服务端发送其证书（可选，取决于使用的加密算法）

    目前业内流行的 RSA 算法，就是基于证书的。使用证书也是更推荐的做法，因为相比于无证书的机制，使用证书更安全

  - 服务端发送 ServerKeyExchange 消息（可选，取决于使用的加密算法。DHE 和 DH_anon 算法会用到）
  - 服务端发送 CertificateRequest 消息，请求获取客户端证书，以便进行相互认证（可选，如果是单向身份认证，通常是服务端认证，则不需要这一步）
  - 服务端发送 ServerHelloDone 消息，表示**服务端握手协商完成**（注意，是协商完成，而不是整个 TLS 握手完成）。
  - 客户端校验服务端证书（如果证书不合法，客户端会**向用户发出警告信息**并**断开 TLS 握手**。后面会介绍如何判断证书的合法性）

- 三次握手

  - 客户端发送其证书，供服务端使用和校验（可选，如果是单向身份认证，通常是服务端认证，则不需要这一步）
  - 客户端发送 ClientKeyExchange 消息（可选，同样取决于使用的加密算法。DHE 和 DH_anon 算法会用到），其中可能包含 Pre-Master-Secret、公钥。

    > Pre-Master-Secret (PMS，预主密钥) 是一个随机数，在发送之前，会使用服务端证书中的公钥对其进行加密。

  - 客户端发送一个 CertificateVerify 消息（可选，如果是单向身份认证，通常是服务端认证，则不需要这一步）

    其中包含使用客户端**私钥**对之前握手信息的签名。服务端可以使用客户端公钥来验证此签名，以确定客户端是否拥有此证书。

  - 到此为止，客户端和服务端都具有了三个随机数（两个随机数 + PMS），然后它们分别使用之前协商的**对称加密算法**和**三个随机数**来生成 Master-Secret，用于加密之后传输的数据

    > Master-Secret（MS，主密钥，也称为 “会话密钥”）

- 四次挥手

  - 客户端发送 ChangeCipherSpec 记录，用于告诉服务端 “之后的所有数据都将进行身份验证（如果服务端证书中存在加密参数，则会进行加密）”。具体如下：

    - 客户端发送经过身份验证和加密的 Finished 消息，其包含之前所有握手信息的 Hash 和 [MAC](https://en.wikipedia.org/wiki/Message_authentication_code)
    - 服务端尝试解密 Finished 消息，获取并验证 Hash 和 MAC。如果解密或验证失败，则认为握手失败，断开 TLS 链接。

  - 服务端回应 ChangeCipherSpec 记录，同样用于告诉客户端 “之后的所有数据都将进行身份验证（如果服务端证书中存在加密参数，则会进行加密）”。具体如下：

    - 服务端发送经过身份验证和加密的 Finished 消息
    - 客户端执行与服务端上一步相同的解密和验证过程

上面对 TLS 四次握手进行了全面的介绍，但比较晦涩难懂，下面我们将其简化并总结一下：

> 由于不用证书的 TLS 握手不够安全，也很少使用，因此这里只讨论需要证书的。

- 一次握手

  - 客户端发送 TLS 握手请求，其中包含**支持的最高 TLS 协议版本**、**随机数**、**加密算法列表**、**压缩算法列表**
  - 服务端回应请求，回应的内容包含**要使用的 TLS 协议版本**、**随机数**、**要使用的加密算法**、**要使用的压缩算法**

- 二次握手

  - 服务端发送其证书，请求获取客户端证书，然后发送 ServerHelloDone 消息
  - 客户端验证服务端证书，如果不合法，则断开 TLS 握手连接

- 三次握手

  客户端发送以下信息：

  - 客户端证书
  - 一个随机数（PMS）。该随机数使用服务端的公钥加密
  - 使用客户端**私钥**对先前握手信息的签名

  此时，客户端和服务端都有了三个随机数，然后双方各自使用协商的对称加密算法和三个随机数，来生成对话密钥（MS），用于加密之后传输的数据。

- 四次挥手

  客户端发送如下信息：

  - 编码改变通知（用于告诉服务端加密传输接下来的数据）
  - 握手结束通知（该通知包含之前所有握手信息的 Hash 和 [MAC](https://en.wikipedia.org/wiki/Message_authentication_code)，供服务端校验）

  服务端发送如下信息：

  - 编码改变通知（用于告诉客户端加密传输接下来的数据）
  - 握手结束通知（该通知包含之前所有握手信息的 Hash 和 [MAC](https://en.wikipedia.org/wiki/Message_authentication_code)，供客户端校验）

## 证书校验

TLS 协议中重要的一环是如何校验证书的真实性。虽然有些 TLS 握手不需要证书（例如，使用 [Diffie-Hellman](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman)（DH） 算法的 TLS 握手），但是这些情况都被证实不安全，而且很少使用，因此这里只讨论需要证书的 TLS 握手。

要证明证书的真实性，通常依赖于**一组**受信任的第三方**证书颁发机构**（Certificate authorities, **CA**）。验证 TLS 证书有效性的方法如下：

1. 检查证书是否是浏览器中**受信任的根证书机构**颁发

   证书都是上级 CA 签发的，上级的 CA 可能还有上级，直到找到根证书。

2. 检查证书中的**证书吊销列表**（CRL），看证书是否已经被吊销

   证书被吊销后，会被记录在证书吊销列表中，CA 会定期发布 CRL。应用程序可以根据 CRL 来检查证书是否被吊销。

3. 通过**在线证书状态协议**（OCSP）检查证书是否有效

   CA 会提供实时的查询接口，用来查询证书的有效性。在线实时查询会使得 TLS 握手时间延长，因为浏览器需要等待查询结束才能继续 TLS 握手。至于使用**在线查询**还是证书中的**吊销列表**，由浏览器决定。

4. 检查证书是否过期
5. 检查域名和证书中的域名是否一致
6. 查询网站是否被列入了欺诈网站黑名单

   这一步 IE7 会进行，IE7 会到**欺诈网站数据库**，查询网站是否被列入了欺诈黑名单。

经过了以上步骤，浏览器中才会显示安全锁的标志。任意一个步骤出问题，浏览器都无法建立安全链接，并最终提示 “您的链接不是私密链接”。

## 对称加密

对称加密，又叫私钥加密，指**加密和解密使用相同密钥的加密算法**。其特点是，加密密钥和解密秘钥可以相互推算出来。并且在大多数对称加密算法中，加密密钥和解密秘钥是相同的。因此，密钥的保密性对通信的安全性至关重要。

优点：计算量小、加密速度快，效率高。
缺点：双方使用同样的密钥，安全性得不到保证。

从以上特点可以看出，如果 TLS 握手阶段使用对称加密，那么只要攻击者窃听到密钥，就可以获取所有通信数据，这使得加密毫无意义。因此，需要用到非对称加密来保证 TLS 握手的安全。

## 非对称加密

上文介绍了 TLS 四次握手，我们知道在数据传输之前，需要**通过协商来交换密钥、加密算法等**。密钥协商阶段常用的非对称加密算法是 [RSA](<https://en.wikipedia.org/wiki/RSA_(algorithm)>)（用于生成**公钥**和**私钥**）。其中，公钥会被包含在证书中，私钥则由客户端或服务端自己来保管。

RSA 算法安全性很高，实现也简单，但缺点是需要比较大的质数（目前业界常用的是 2048 位）来保证安全强度，并且运算极其消耗 CPU 资源。

一次完全的 TLS 握手中，在密钥交换阶段，非对称加密的计算量占整个握手过程的 90% 以上，而对称加密的计算量只相当于非对称加密的 0.1%。所以，如果后续的数据传输也使用非对称加密，则会极其消耗 CPU 性能，服务器根本无法承受。

此外，非对称加密有一个限制：加密的内容长度不能超过公钥的长度。例如，常用的公钥长度为 2048 位，意味着加密内容不能超过 256 个字节。

因此，非对称加密目前只适用于**密钥协商**或 **CA 签名**，不适用于传输数据的加解密，这也就是为什么不全程使用非对称加密的原因。另外，只要 TLS 握手足够安全（指的是：交换的**对称密钥**无法被破解、利用），那么在数据传输时，使用对称加密就足够安全。

## 握手恢复

TLS 握手阶段使用了非对称加密（例如 RSA 算法），其计算消耗非常大，因此 TLS 握手机制中提供了会话恢复的功能，从而提高了握手中断后再次握手的性能。

有两种方法可以恢复会话：一种是 Session ID，另一种是 Session tickets。

### Session ID

Session ID 的思想很简单：每次会话都有一个会话 ID。如果 TLS 握手中断，下次重连的时候，只要客户端给出会话 ID，并且服务端有对应的记录，那么双方就可以使用之前的 “会话密钥”，而不必重新计算生成。

其具体过程如下：每次会话中，服务器发送会话 ID 作为 ServerHello 消息的一部分。客户端将此会话 ID 与服务端的 IP、TCP 端口相关联，以便下次重连时简化握手。服务端将此会话 ID 与之前协商的密钥相关联，特别是 “会话密钥”。双方必须具有相同的 “会话密钥”，否则握手恢复失败（用于防止攻击者利用会话 ID）。

### Session tickets

Session ID 的缺点是：只能保留在一台服务器上。所以，如果客户端的请求发送到另一台服务器上（一个应用的服务器往往有很多个，因此客户端请求数据时，很可能和多个服务器交互），就无法恢复会话。Session tickets 的出现就是为了解决这个问题。

Session tickets 由服务器加密和认证，服务器在使用之前会验证其有效性。

使用 Session tickets 时，服务器将**会话状态**存储在其中，并将其存储到客户端。客户端在恢复会话时，将 Session tickets 发送给服务端，服务器验证后，使用其中的会话状态来恢复会话。

## TLS 安全性

从 TLS 的原理可知，其设计是严谨、可靠的，但是问题出现在不严谨的使用中。

常见的攻击是中间人攻击（Man-in-the-middle, MITM），它是指 A 和 B 通信时，有第三者 C 处于信道中间，可以完全劫持、窃听、篡改这些信息。

上文中也一直强调，不使用证书的 TLS 握手是不安全的。例如，使用密钥交换算法 [DH](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman)，该算法就没有证书的概念，这样攻击者就可以轻易窃听、篡改数据，从而冒充他人。

有了证书之后，如果攻击者替换了证书，并且浏览器发出警告信息 “您的链接不是私密链接”，但是仍有用户选择继续访问，这同样使得用户数据的安全性无法保证。

总结来说，包括但不限于以下两点：

- 访问带证书的链接
- 浏览器发出警告时，停止访问

因此很多时候，数据的一部分安全性掌握在我们自己手中。

---

参考资料：

- [SSL/TLS 协议运行机制的概述](https://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)
- [深入揭秘 HTTPS 安全问题&连接建立全过程](https://zhuanlan.zhihu.com/p/22142170)
- [从网络协议的角度聊一聊最近 Github 被大规模攻击事件](https://mp.weixin.qq.com/s/AI0mjOZxBx3bRn71CjbY3w?client=tim&ADUIN=1656081615&ADSESSION=1585797524&ADTAG=CLIENT.QQ.5603_.0&ADPUBNO=26933)
- [SSL/TLS 原理详解](https://www.linuxidc.com/Linux/2016-05/131147.htm)
