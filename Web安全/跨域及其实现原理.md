常见的跨域方法及其实现原理。

## 为什么会跨域

浏览器为了保证内容的安全，采取了同源策略，从而尽可能的减少 XSS、CSRF 攻击。因此只要违背了同源策略，就会产生跨域问题。

所谓同源，是指**协议、域名、端口**都相同，即便两个不同的域名指向同一个 IP，也非同源。

同源策略限制的内容有：

- Cookie、LocalStorage 等存储的内容
- DOM 节点
- Ajax 请求发送后，返回的结果

但是有三种标签允许跨域资源加载：

- `<img src="xxx">`
- `<link href="xxx">`
- `<script src="xxx"></script>`

## 常见的跨域场景

一个 URL 的结构如下所示：

![](./images/url-struct.png)

当**协议、域名、子域名、端口号**中，任意一个不同时，都算作不同域。不同域之间请求数据时，就会产生“跨域”。

常见的跨域场景举例：

|URL|说明|是否允许通讯|
|:---|:---:|:---:|
|`http://a.com/a.js` <br> `http://a.com/dist/b.js`|同一域名，不同路径|允许|
|`http://a.com:80/a.js` <br> `http://a.com:81/a.js`|同一域名，不同端口|不允许|
|`http://a.com/a.js` <br> `https://a.com/a.js`|同一域名，不同协议|不允许|
|`http://www.a.com/a.js` <br> `http://xx.xx.xx.xx/a.js`|域名和域名对应的 IP|不允许|
|`http://a.com/a.js` <br> `http://www.a.com/a.js` <br> `http://blog.a.com/a.js`|主域相同，子域不同|不允许|
|`http://www.a.com/a.js` <br> `http://www.b.com/a.js`|不同域名|不允许|

需要特别注意的一点：**如果是协议和端口造成的跨域问题，前端是无能为力的**。

或许你有个疑问，**请求跨域的时候，请求发出去了没有？**

**跨域的时候，请求可以发出去，服务端也可以接收请求并返回响应，只是结果被浏览器拦截了**。

## 跨域解决方案

目前常用的跨域方案有以下几种：

1. JSONP
2. CORS
3. `postMessage`
4. WebSocket
5. Node.js 代理
6. Nginx 反向代理
7. `window.name` + `<iframe>`
8. `location.hash` + `<iframe>`
9. `document.domain` + `<iframe>`

### JSONP

JSONP 的原理很简单，就是**利用 `<script>` 标签不受同源策略限制的性质，从而实现跨域请求**。不过 JSONP 请求需要对方的服务器做支持才可以。

1）JSONP 的实现

> 推荐大家跟着文章，敲一敲代码来加深理解 。

前端代码（简单版）：

```html
// index.html

<script>
  // 提前声明好回调函数
  window.show = function (res) {
    console.log(res)
  }
</script>
<script src='http://localhost:8080/jsonp?msg=hello&cb=show'></script>
```

其中，利用 `<script>` 请求 `http://localhost:8080/jsonp` 接口，并携带 `msg` 和 `cb` 参数。`msg` 参数用于携带数据（`hello`），`cb` 参数用于传递回调函数（`show`）。

然后，我们利用 Express 框架搭建一个简易的后端服务器：

```js
// server.js

const express = require('express');
const app = express();

app.get('/jsonp', function (req, res) {
  const { msg, cb } = req.query;

  console.log(msg); // hello
  console.log(cb);  // show

  // 把数据和回调函数拼接成字符串，返回给前端
  // => show('world')
  res.send(`${cb}('world')`);
  res.end();
});

app.listen(8080);
```

启动后端服务器，执行指令：

```bash
$ node server.js
```

在浏览器里运行 `index.html` 文件，可以看到控制台输出了 `world` 信息。整个过程如下：

1. 后端将**要发送的数据**和**回调函数**拼接成字符串，返回给前端。
2. 前端请求 `http://localhost:8080/jsonp?msg=hello&cb=show`，接收到的是 `show('world')`。
3. 我们都知道，`<script>` 加载完资源后，会执行其中的内容。因此接收到的 `show('world')` 会被执行。

为了方便使用，我们封装一下前端代码：

```html
// index.html

<script>
function jsonp({ url, params, callback }) {
  return new Promise((resolve, reject) => {
    let script = document.createElement('script');
    let param = { ...params, callback };
    let arrs = [];

    for (let key in param) {
      arrs.push(`${key}=${param[key]}`)
    }

    script.src = `${url}?${arrs.join('&')}`;
    document.body.appendChild(script);

    window[callback] = function(data) {
      document.body.removeChild(script);
      resolve(data);
    }
  });
}

jsonp({
  url: 'http://localhost:8080/jsonp',
  params: { name: '文一', age: '22' },
  callback: 'show'
}).then(data => {
  console.log(data);
});
</script>
```

2）JSONP 的优缺点

JSONP 方案的优点是**兼容性好**，缺点是**仅支持 GET 方法，并且可能会遭到 XSS 攻击**。

### CORS

CORS 是 W3C 标准，全称“跨域资源共享”，它使用额外的 HTTP 标头来告诉浏览器“允许访问不同源的资源”。

1）CORS 请求类型

CORS 请求有两种：1、**简单请求**。不携带 Cookie，前端无须设置，服务端设置 `Access-Control-Allow-Origin` 即可。2、**复杂请求**。携带 Cookie，前后端都需要设置。

因此，实现 CORS 跨域通信的关键是服务器。

1.1）简单请求

只要同时满足以下两个条件，就属于简单请求：

1. 请求方法是 `HEAD`、`GET`、`POST` 之一
2. HTTP 的头信息不超出以下几种字段

    - `Accept`
    - `Accept-Language`
    - `Content-Language`
    - `Last-Event-ID`
    - `Content-Type`：只限于三个值 `application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

1.2）复杂请求

不符合以上条件的，即为复杂请求。复杂请求会在正式通信之前，进行一次“预检请求”，其请求方法是 `OPTIONS`。

2）配置示例

**前端设置**

- 原生 Ajax

  ```js
  // 设置是否携带 Cookie
  xhr.withCredentials = true;
  ```

- jQuery

  ```js
  $.ajax({
    ...
    xhrFields: {
    // 设置是否带 Cookie
    withCredentials: true
    },
    // 让请求头中包含额外的跨域信息，但不包含 Cookie
    crossDomain: true,
    ...
  });
  ```

- Axios

  ```js
  // 设置是否带 Cookie
  axios.defaults.withCredentials = true
  ```

- Vue

  ```js
  // 设置是否带 Cookie
  Vue.http.options.credentials = true
  ```

**后端设置**

- Java

  ```java
  // 允许跨域访问的域名
  response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com");

  // 提示 OPTIONS 预检时，后端需要设置的两个常用自定义头
  response.setHeader("Access-Control-Allow-Headers", "Content-Type,X-Requested-With");

  // 允许访问的方法
  response.setHeader("Access-Control-Allow-Methods", "PUT");

  // 允许前端请求携带 Cookie
  // 启用此项后，上面的域名不能为 "*"，必须指定具体的域名
  response.setHeader("Access-Control-Allow-Credentials", "true"); 
  ```

- Node.js

  ```js
  let express = require('express');
  let app = express();
  // 设置白名单
  let whitList = ['http://localhost:3000'];

  app.use(function(req, res, next) {
    let origin = req.headers.origin;

    if (whitList.includes(origin)) {
      // 允许访问的源
      res.setHeader('Access-Control-Allow-Origin', origin);
      // 允许携带的 HTTP 头
      res.setHeader('Access-Control-Allow-Headers', 'X-Custom-Header');
      // 允许哪个方法访问
      res.setHeader('Access-Control-Allow-Methods', 'PUT');
      // 允许携带 Cookie
      res.setHeader('Access-Control-Allow-Credentials', true);

      // OPTIONS 请求不做任何处理
      if (req.method === 'OPTIONS') {
        res.end();
      }
    }
    next();
  });

  app.put('/getData', function(req, res) {
    res.setHeader('foo', 'bar');
    res.end('hello world');
  });
  app.get('/getData', function(req, res) {
    res.end('hello world');
  });
  app.use(express.static(__dirname));
  app.listen(8080);
  ```

### postMessage


