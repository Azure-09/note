# 前端常用的设计模式

模式是一种可复用的解决方案，用于解决软件设计中遇到的常见问题。说白了，就是**套路**，而编程的套路就是“设计模式”。

设计模式就是**在软件设计、开发过程中，针对特定问题、场景的更优解决方案**。

## 为什么需要设计模式

设计模式是前辈们针对开发中遇到的问题，提出大家公认且有效的解决方案。当我们遇到相似的问题、场景时，套用设计模式就可以快速找到更优的解决方式。

如果我们的代码不遵循任何设计模式，可能会导致设计缺陷、代码缺陷，为后期维护、迭代带来麻烦。

简单来说，**合理的**使用设计模式，可以使我们的代码更易维护、更优雅、更易扩展等。

## 设计模式分类

所有的设计模式大概有几十种，什么享元模式、外观模式、生成器模式啥的，很多都不太常用。这里只介绍几种前端常用的设计模式：

- 策略模式
- 发布-订阅模式
- 装饰器模式
- 适配器模式
- 代理模式
- 责任链模式

下面进行详细介绍时，都会通过具体例子来引出，来方便理解。

### 策略模式

例如，我们要实现**权限判断**的逻辑。

需求：如果想要查看其他 Github 用户的**私有**仓库，需要满足以下条件

- 是 Github 用户
- 是该仓库的 Contributor

如果只是实现该逻辑很简单，大多数人的第一反应就是 `if-else` 一把梭：

```js
function checkAuth(data) {
  if (data.role !== 'github') {
    console.log('不是 Github 用户');
    return false;
  }

  // 既不是核心成员，也不是普通成员
  if (data.auth !== 'core' && data.auth !== 'contributor') {
    console.log('不是该仓库的 Contributor');
    return false;
  }
}
```

这样写带来的问题是：

- 当很多判断逻辑进行组合时，`checkAuth` 函数会爆炸
- 每个判断逻辑无法复用
- 违反开放封闭原则

通过上面的介绍，这里再给出策略模式的定义就更容易理解了：**要实现某个功能，有多种逻辑可以选择。我们定义策略，把逻辑一个个封装起来，并且使它们可以相互组合**。

下面我们用**策略模式**重构上面的代码逻辑：

```js
// 策略
const strategies = {
  checkRole: function (value) {
    return value === 'github';
  },
  checkAuth: function (value) {
    // 维护一个权限列表
    const listAuths = ['core', 'contributor'];

    return listAuths.includes(value);
  }
};
```

策略定义完了，下面是校验策略：

```js
// 校验规则
const Validator = function () {
  this.checkers = [];
};

// 添加策略
Validator.prototype.add = function (method, value) {
  this.checkers.push(() => strategies[method](value));
};

// 检查策略
Validator.prototype.check = function () {
  return this.checkers.every((valid) => valid());
};
```

最后，组合使用策略，来实现判断逻辑：

```js
// 是否有权限查看其他人的 Github 私有仓库
const checkRepoAuth = function (data) {
  const validator = new Validator();

  validator.add('checkRole', data.role);
  validator.add('checkAuth', data.auth);

  return validator.check();
};

const auth1 = {
  role: 'github',     // Github 用户
  auth: 'contributor' // 仓库的贡献成员
};
const auth2 = {
  role: 'visitor',    // 游客（不是 Github 用户）
  auth: ''
};

const hasRepoAuth1 = checkRepoAuth(auth1);
const hasRepoAuth2 = checkRepoAuth(auth2);

console.log(hasRepoAuth1); // => true
console.log(hasRepoAuth2); // => false
```

可以看出，重构之后的代码比疯狂写 `if-else` 好太多了！虽然代码量比重构之前多，而且阅读难度有所增大，但是带来的好处是不可估量的。

如果需求更改，代码维护起来也很方便。例如，权限判断条件改为：

- 是 Github 用户
- 是该仓库的 Contributor
- 注册时间大于 1 年

添加新的策略：

```diff
// 策略
const strategies = {
  checkRole: function (value) {
    return value === 'github';
  },
  checkAuth: function (value) {
    return listAuths.includes(value);
  },
+ checkYear: function (value) {
+   return value > 1;
+ }
};
```

复用新旧策略，组合出新的逻辑（方案）：

```js
const checkRepoAuth2 = function (data) {
  const validator = new Validator();

  validator.add('checkRole', data.role);
  validator.add('checkAuth', data.auth);
  validator.add('checkYear', data.year);

  return validator.check();
};
```

当然，策略模式还适用于很多其他功能：

- **表单验证**（账户、密码、手机号、邮箱、...）
- **上传文件验证**（大小 5MB、类型 PNG/JPG、...）
- **计算商品价格**（满 100 减 20、满 200 减 50、八折、...）
- **......**

策略模式的**适用场景**：

- 策略相互独立且可复用
- 策略需要灵活组合

### 发布-订阅模式

### 装饰器模式

### 适配器模式

### 代理模式

### 责任链模式
